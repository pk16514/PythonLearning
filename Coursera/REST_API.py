"""
1. REST - Representational State Transfer
   API - Application Programming Interface
   DNS - Domain Name System
   HTTP - HyperText Transfer Protocol

2. API is an interface that lets one computer interact with another computer program and REST.
   An API specifies how an external program (an application program) can request that a program
   perform certain computations.

3. A 'REST API' just means a website that produces data intended for another computer program
   to consume rather than something intended to be displayed to people in a browser.

4. Putting the two together, a REST API specifies how external programs can make HTTP requests
   to a web site in order to request that some computation be carried out and data returned as
   output. When a website is designed to accept requests generated by other computer programs,
   and produce outputs to be consumed by other programs, it is sometimes called a web service,
   as opposed to a web site which produces output meant for humans to consume in a web browser.

5. A 'REST API' will respond to requests in a particular format and some things are common
   across many APIs about the format but some things are specific to particular API.

6. A particular URL like http://umich.edu/about has three parts like
   {protocol}://{server}/{paths or arguments}
   <scheme>://<host>:<port>/<path>
   --> protocol tells us how to communicate with that remote server
   --> server tells us where to fetch data
   --> arguments tells us what to fetch from the remote server

7. Every Computer that's attached to the internet has a unique identifier, an address.
   It's called the IP(Internet Protocol) address.

8. No two computers that are connected to the internet have the same IP address at the same time.
   When the computer disconnects, you might get another computer getting to reuse that IP address.

9. When we have a domain name like 'www.si.umich.edu', that's of a more permanent name but the actual
   server that is responding to that name may change over time, and each server will have an IP address.
   So the Internet has something called DNS(Domain Name System) that is setup to resolve names like
   'www.si.umich.edu' and turn them into these unique identifiers, the IP adresses.

10. Behind the Scenes of http Request:-
   --> Translate domain name to IP adress
   --> Open a connection
       - set up encryption keys if https
   --> start sending messages using the http protocol
       - GET {arguments}
         - also send "headers"
       - Receive HTML
         - also some "headers"
       - Browser renders the HTML

11. A very common URL Structure-
    https://events.umich.edu/list?filter=tags:Art,&range=2018-10-01

    --> Protocol: https
        - Encrypted communication
    --> Host: events.umich.edu
        - Server for Student's Life Happening@Michigan
    --> Arguments: list?filter=tags:Art,&range=2018-10-01
        - (format is always server-specific)
        - I want a list of events that are:
          - Tagged with 'art'
          - Starting on 1st Oct, 2018
    This is a very common URL structure which has list as a path and then a question mark
    after that key equals value pairs.

12. Each device has a globally distinct IP address, which is a 32 bit number. Usually an
    IP address is represented as a sequence of four decimal numbers, each number in the
    range (0, 255). For example, when I checked the IP address for my laptop just now, it
    was 141.211.203.248. Any IP address beginning with 141.211 is for a device at the
    University of Michigan. When I take my laptop home and connect to a network there, my
    laptop gets a different IP address that it uses there.

13. Data is chopped up into reasonable sized packets (up to 65,535 bytes, but usually much smaller).

14. Each data packet has a header that includes the destination IP address.

15. Each packet is routed independently, getting passed on from one computing device to another
    until it reaches its destination. The computing devices that do that packet forwarding are
    called routers. Each router keeps an address table that says, when it gets a packet for some
    destination address, which of its neighbors should it pass the packet on to. The routers are
    constantly talking to each other passing information about how they should update their routing
    tables. The system was designed to be resistant to any local damage. If some of the routers
    stop working, the rest of the routers talk to each other and start routing packets around in
    a different way so that packets still reach their intended destination if there is some path
    to get there. It is this technical capability that has spawned metaphoric quotes like this one
    from John Gilmore: “The Net interprets censorship as damage and routes around it.”

16. At the destination, the packets are reassembled into the original data message.

17. Usually, the scheme will be http or https. Other schemes that you will sometimes see include
    ftp (for file transfer) and mailto (for email addresses).

18. The host can be an IP address directly. This is less common, because IP addresses are harder
    to remember and because a URL containing a domain name will continue to work even if the remote
    server keeps its domain name but moves to a different IP address.

19. The :port is optional. If it is omitted, the default port number is 80. The port number is used
    on the receiving end to decide which computer program should get the data that has been received.
    We probably will not encounter any URLs that include the : and a port number in this course.
    The port number for https is 443.

20. The HTTP Protocol:-
    HTTP is the protocol that specifies how web browsers or other programs communicate with web servers.
    Step 1: the client makes a request to the server.(Check Image http1)
        --> If the request only involves fetching data, the client sends a message of the form GET
            <path>, where <path> is the path part of the URL

        --> If the request involves sending some data (e.g., a file upload, or some authentication
            information), the message starts with POST

        --> In either case, the client sends some HTTP headers. These include:
            - The type of client program. This allows the server to send back different things to
              small mobile devices than desktop browsers (a “responsive” website)

            - Any cookies that the server previously asked the client to hold onto. This allows
              the server to continue previous interactions, rather than treating every request as
              stand-alone. It also allows ad networks to place personalized ads.

        --> After the HTTP headers, for a POST type communication, there is some data (the body
            of the request).

    Step 2: the server responds to the client.(check image http2)
        --> The server first sends back some HTTP headers. These include:
            - a response code indicating whether the server thinks it has fulfilled the request or not.

            - a description of the type of content it is sending back (e.g., text/html when it is
              sending html-formatted text).

            - any cookies it would like the client to hold onto and send back the next time it
              communicates with the server.

        --> After the headers come the contents. This is the stuff that you would see if you ask to
            “View Source” in a browser.

21. Encoding URL Parameters-
    Here’s another URL that has a similar format.
    https://www.google.com/search?q=%22violins+and+guitars%22&tbm=isch.
    It’s a search on Google for images that match the string “violins and guitars”. It’s not actually
    based on a REST API, because the contents that come back are meant to be displayed in a browser.
    But the URL has the same structure we have been exploring above and introduces the idea of
    “encoding” URL parameters.

    --> The base URL is https://www.google.com/search
    --> ?
    --> Two key=value parameters, separated by &
        - q=%22violins+and+guitars%22 says that the query to search for is “violins and guitars”.
        - tbm=isch says to go to the tab for image search

    Now why is "violins and guitars" represented in the URL as %22violins+and+guitars%22? The answer
    is that some characters are not safe to include, as is, in URLs. For example, a URL path is not
    allowed to include the double -quote character. It also can’t include a : or / or a space.
    Whenever we want to include one of those characters in a URL, we have to encode them with other
    characters. A space is encoded as +. " is encoded as %22. : would be encoded as %3A. And so on.

22. A Response object, in the full implementation of the requests module has the following useful
    attributes that can be accessed in your program:
    --> The .text attribute. It contains the contents of the file or other information available
        from the url (or sometimes an error message).

    --> The .url attribute. We will see later that requests.get takes an optional second parameter
        that is used to add some characters to the end of the base url that is the first parameter.
        The .url attribute displays the full url that was generated from the input parameters.
        It can be helpful for debugging purposes; you can print out the URL, paste it into a browser,
        and see exactly what was returned.

    --> The .status_code attribute.
        - When a server thinks that it is sending back what was requested, it sends the code 200.

        - When the requested page doesn’t exist, it sends back code 404, which is sometimes described
          as “File Not Found”.

        - When the page has moved to a different location, it sends back code 301 and a different URL
          where the client is supposed to retrieve from. In the full implementation of the requests
          module, the get function is so smart that when it gets a 301, it looks at the new url and
          fetches it. For example, github redirects all requests using http to the corresponding page
          using https (the secure http protocol). Thus, when we ask for
          http://github.com/presnick/runestone, github sends back a 301 code and the url
          https://github.com/presnick/runestone. The requests.get function then fetches the other url.
          It reports a status of 200 and the updated url. We have to do further inquire to find out
          that a redirection occurred.

    --> The .headers attribute has as its value a dictionary consisting of keys and values. To find
        out all the headers, you can run the code and add a statement print(p.headers.keys()). One
        of the headers is ‘Content-type’. Some possible values are text/html; charset-utf-8 and
        application/json; charset=utf-8.

    --> The .history attribute contains a list of previous responses, if there were redirects.

    --> The .json() method. This converts the text into a python list or dictionary, by passing the
        contents of the .text attribute to the jsons.loads function.

23. The get function in the requests module takes an optional parameter called params. If a value
    is specified for that parameter, it should be a dictionary. The keys and values in that dictionary
    are used to append something to the URL that is requested from the remote site.
"""

# Program-1


import requests
import json

page = requests.get("https://api.datamuse.com/words?rel_rhy=funny")
print(type(page))
print(page.text[:150])
print(page.url)
print(page.headers.keys())
print("------")
# turn page.text into a python object
# x = page.json()
x = json.loads(page.text)
print(type(x))
print("---first item in the list---")
print(x[0])
print("---the whole list, pretty printed---")
print(json.dumps(x, indent=2))
print()

# Program-2


d = {'q': 'violins and guitars', 'tbm': 'isch'}
results = requests.get("https://google.com/search", params=d)
print(results.text[:150])
print(results.url)
print()

# Program-3


def get_rhymes(word):
    baseurl = "https://api.datamuse.com/words"
    params_diction = {}
    params_diction["rel_rhy"] = word
    params_diction["max"] = "3"
    resp = requests.get(baseurl, params=params_diction)
    print(resp.url)
    # return the top three words
    word_ds = resp.json()
    return [d['word'] for d in word_ds]
    return word_ds


print(get_rhymes("funny"))
print(get_rhymes("dash"))
